# lab1实验报告
## 实现功能

添加了读取当前正在执行的任务信息的系统调用。任务信息作为一个结构体，包含三个字段：运行状态、系统调用种类与次数、运行时间。运行状态从任务管理器中各个任务的任务控制块(TaskControlBlock)可以直接读取到。系统调用种类与次数是我在任务控制块中新增了调用次数字段，在syscall函数match syscall_id分发前添加了记录步骤实现的。运行时间我在任务控制块中添加了一个Option<usize>结构的字段，None表示还没被调度运行过，Some(usize)记录了任务首次被调度运行时的毫秒时间（使用get_time_us()/1000计算而来），分别在run_first_task和run_next_task添加记录语句，在获取任务信息时再次用get_time_us()/1000减去首次调度时间即可得到运行时间。将这三项封装进任务信息结构体作为系统调用的结果即可。

## 简答作业
1. 正确进入 U 态后，程序的特征还应有：使用 S 态特权指令，访问 S 态寄存器后会报错。 请同学们可以自行测试这些内容 (运行 Rust 三个 bad 测例 (ch2b_bad_*.rs) ， 注意在编译时至少需要指定 LOG=ERROR 才能观察到内核的报错信息) ， 描述程序出错行为，同时注意注明你使用的 sbi 及其版本。  

    __答__：RustSBI version 0.2.2。报错如下：  
    ```
        [ERROR] [kernel] PageFault in application, bad addr = 0x0, bad instruction = 0x80400408, core dumped.  
        [ERROR] [kernel] IllegalInstruction in application, core dumped.  
        [ERROR] [kernel] IllegalInstruction in application, core dumped.  
    ```


2. 深入理解 trap.S 中两个函数 __alltraps 和 __restore 的作用，并回答如下问题:

    1. L40：刚进入 __restore 时，a0 代表了什么值。请指出 __restore 的两种使用情景。 
 
        __答__： a0代表了内核栈中Trap上下文的栈顶地址。
        
        __restore的两个场景：  
        * 首次调度运行起任务时用于把我们构造的Trap上下文给还原到现场中，从内核态进入用户态让任务跑起来。  
        * 处理完Trap后从内核态返回用户态。  
        
    2. L46-L51：这几行汇编代码特殊处理了哪些寄存器？这些寄存器的的值对于进入用户态有何意义？请分别解释。

         __答__：处理了：  
         * sstatus：它的SPP等字段标识了发生Trap前处于什么特权级，用于在处理完Trap之后正确的返回到用户态  
         * sepc：记录Trap发生之前执行的最后一条指令的地址，等一会用sret就会跳回这个地址的用户态流程继续执行  
         * sscratch：存储着用户栈的栈顶地址，这里先是把它从栈中还原到寄存器中，之后交换sp与sscratch可以达到从内核栈换到用户栈的效果  
    
    3. L53-L59：为何跳过了 x2 和 x4？

        __答__：
          * x2就是sp，在这里存的是用户栈顶的地址，已经在L46-L51中还原到sstatus寄存器中去了，目前的sp里存的是内核栈顶的地址，之后会交换sp和sstatus达到切换用户栈与内核栈的目的。如果这里直接还原则会造成目前的sp被直接覆盖掉，导致内核栈顶的地址永久丢失。
          * x4是一个线程指针寄存器，目前用不到所以无需保存和恢复。  

    4. L63：该指令之后，sp 和 sscratch 中的值分别有什么意义？  
      
        __答__：这时一条把内核栈挂起、把用户栈激活的指令。该指令之后，sp是用户栈顶地址，sscratch是内核栈顶地址。  
      
    5. __restore：中发生状态切换在哪一条指令？为何该指令执行之后会进入用户态？  
    
        __答__： sret。该指令会将当前的特权级按照sstatus的SPP字段设置为U或者S，然后跳转到sepc寄存器记录的用户态Trap前的指令继续执行。  
    
    6. L13：该指令之后，sp 和 sscratch 中的值分别有什么意义？  

        __答__：这时一条把用户栈挂起、把内核栈激活的指令。该指令之后，sp是内核栈顶地址，sscratch是用户栈顶地址。  
      
    7. 从 U 态进入 S 态是哪一条指令发生的？  
    
        __答__：ecall。  
